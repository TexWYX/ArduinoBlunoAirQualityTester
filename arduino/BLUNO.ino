#include <avr/pgmspace.h>
#include <Wire.h>
#include <Arduino.h>
#include <PlainProtocol.h>
#include <LiquidCrystal_I2C.h>

#define dht11_pin 15
#define RedLedPin 9
#define GreenLedPin 10
#define BlueLedPin  3
#define RockerPin 0
#define KnobPin 1
#define RelayPin 11
#define BuzzerPin 8

LiquidCrystal_I2C lcd(0x27,16,2); 

int measurePin = 0; //Connect dust sensor to Arduino A0 pin
int measureled = 14;   //Connect 3 led driver pins of dust sensor to Arduino D14
  
int samplingTime = 280;
int deltaTime = 40;
int sleepTime = 9680;
  
float voMeasured = 0;
float calcVoltage = 0;
float dustDensity = 0;

PlainProtocol BLUNOPlainProtocol(Serial,115200);

int humid=0;
int temper=0;

char key_value=0;
char ch_buf[17]={0};
int UG2864Address = 0x3C;
int RES = 6;//Gadgeteer PIN6
int DC = 7;//Gadgeteer PIN3

void Writec(unsigned char COM)
{
  Wire.beginTransmission(UG2864Address);
  Wire.write(0x00);
  Wire.write(COM);
  Wire.endTransmission();
}

void Writed(unsigned char DATA)
{
  Wire.beginTransmission(UG2864Address);
  Wire.write(0x40);
  Wire.write(DATA);
  Wire.endTransmission();
}

void SSD1306()
{
  Writec(0XAE);//display off
  Writec(0X00);//set lower column address
  Writec(0X10);//set higher column address
  Writec(0X40);//set display start line
  Writec(0XB0);//set page address
  Writec(0X81);//set contract control
  Writec(0XCF);// VCC Generated by Internal DC/DC Circuit
  Writec(0XA1);//set segment remap  column address 127 is mapped to SEG0
  Writec(0XA6);//normal / reverse   normal display
  Writec(0XA8);//multiplex ratio
  Writec(0X3F);//1/64
  Writec(0XC8);//Com scan direction remapped mode. Scan from COM[N-1] to COM0
  Writec(0XD3);//set display offset
  Writec(0X00);
  Writec(0XD5);//set osc division
  Writec(0X80);
  Writec(0XD9);//set pre-charge period
  Writec(0X11);
  Writec(0XDa);//set COM pins
  Writec(0X12);
  Writec(0X8d);/*set charge pump enable*/
  Writec(0X14);
  Writec(0Xdb);//Set VcomH
  Writec(0X20);
  Writec(0XAF);//display ON
}
void fill(unsigned char dat)
{
  unsigned char i,j;
  
  Writec(0x00);//set lower column address
  Writec(0x10);//set higher column address
  Writec(0xB0);//set page address
  
  for(j=0;j<8;j++)
  {
    Writec(0xB0+j);//set page address
    Writec(0x00);//set lower column address
    Writec(0x10);//set higher column address
    for(i=0;i<128;i++)
    {
      Writed(dat);
    }
  }
}


byte read_dht11_dat()
{
  byte n = 0;
  byte result=0;
  for(n=0; n< 8; n++)
  {
    while (!digitalRead(dht11_pin));
    delayMicroseconds(30);
    if (digitalRead(dht11_pin) != 0 )
      bitSet(result, 7-n);
    while (digitalRead(dht11_pin));
  }
  return result;
}

void dht11Init()
{
  pinMode(dht11_pin, OUTPUT);
  digitalWrite(dht11_pin, HIGH);
}

uint8_t dht11GetData()
{
  uint8_t humidity=0;
  uint8_t temperature=0;
  byte dht11_dat[5];
  byte dht11_in;
  byte i;// start condition
  
  digitalWrite(dht11_pin, LOW);
  delay(18);
  digitalWrite(dht11_pin, HIGH);
  delayMicroseconds(1);
  pinMode(dht11_pin, INPUT);
  delayMicroseconds(40);
  
  if (digitalRead(dht11_pin))
  {
        return -1;

//    Serial.println("ERR"); // wait for DHT response signal: LOW
    
  }
  delayMicroseconds(80);
  if (!digitalRead(dht11_pin))
  {
        return -1;

//    Serial.println("ERR");  //wair for second response signal:HIGH
    
  }
  
  delayMicroseconds(80);// now ready for data reception
  for (i=0; i<5; i++)
  {
    dht11_dat[i] = read_dht11_dat();
  }  //recieved 40 bits data. Details are described in datasheet
  
  pinMode(dht11_pin, OUTPUT);
  digitalWrite(dht11_pin, HIGH);
  byte dht11_check_sum = dht11_dat[0]+dht11_dat[2];// check check_sum
  if(dht11_dat[4]!= dht11_check_sum)
  {
        return -1;
//    Serial.println("ERR");
  } 
  humidity = dht11_dat[0];
  temperature = dht11_dat[2];
  humid=humidity;
  temper=temperature;
  
  //  if(flag==0)
  //    return humidity;
  //  else
  //    return temperature;
  
}

 float measure(){
  digitalWrite(measureled,LOW); // power on the LED
  delayMicroseconds(samplingTime);
  
  voMeasured = analogRead(measurePin); // read the dust value
  
  delayMicroseconds(deltaTime);
  digitalWrite(measureled,HIGH); // turn the LED off
  delayMicroseconds(sleepTime);
  // 0 - 5V mapped to 0 - 1023 integer values
  // recover voltage
  //calcVoltage = voMeasured * (5 / 1024);

  // linear eqaution taken from http://www.howmuchsnow.com/arduino/airquality/
  // Chris Nafis (c) 2012
  //dustDensity = 0.17 * calcVoltage - 0.1;
  
  return voMeasured;
}

void lcddsp()
{
    lcd.clear();
    lcd.setCursor(0,0);
    lcd.print("H: ");
    lcd.print(humid);
    lcd.print("%");
    lcd.setCursor(9,0);
    lcd.print("T: ");
    lcd.print(temper);
    lcd.print("C");
    lcd.setCursor(0,1);
    lcd.print("Measure: ");
    lcd.print(measure());
}

void setup() {
  Serial.begin(115200);
  TCCR1B &= ~((1<<CS12)|(1<<CS11)|(1<<CS10));	//Clock select: SYSCLK divde 8;
  TCCR1B |= (1<<CS11);
  TCCR2B &= ~((1<<CS12)|(1<<CS11)|(1<<CS10));	//Clock select: SYSCLK divde 8;
  TCCR2B |= (1<<CS11);
  pinMode(BuzzerPin, OUTPUT);
  pinMode(RelayPin, OUTPUT);

  analogWrite(RedLedPin, 255);
  analogWrite(GreenLedPin, 255);
  analogWrite(BlueLedPin, 255);
  delay(200);
  dht11Init();
  lcd.init();
  lcd.backlight();
  
  pinMode(measureled,OUTPUT);
}


void loop()
{
  //valid frame received
  if (BLUNOPlainProtocol.available()) {
    if (BLUNOPlainProtocol.receivedCommand=="BUZZER") {
      digitalWrite(BuzzerPin, BLUNOPlainProtocol.receivedContent[0]);
    }
    else if (BLUNOPlainProtocol.receivedCommand=="RELAY"){
      digitalWrite(RelayPin, BLUNOPlainProtocol.receivedContent[0]);
    }
    else if(BLUNOPlainProtocol.receivedCommand=="RGBLED")
    {
      analogWrite(RedLedPin, map(BLUNOPlainProtocol.receivedContent[0], 0, 255, 255, 0));
      analogWrite(GreenLedPin, map(BLUNOPlainProtocol.receivedContent[1], 0, 255, 255, 0));
      analogWrite(BlueLedPin, map(BLUNOPlainProtocol.receivedContent[2], 0, 255, 255, 0));
    }
    else if(BLUNOPlainProtocol.receivedCommand=="TEMP")
    {
      BLUNOPlainProtocol.write("TEMP", temper);
    }
    else if(BLUNOPlainProtocol.receivedCommand=="HUMID")
    {
      BLUNOPlainProtocol.write("HUMID", humid);
    }
    else if(BLUNOPlainProtocol.receivedCommand=="KNOB")
    {
      BLUNOPlainProtocol.write("KNOB",measure());
    }
  }
  
  static unsigned long temperatureTimer=millis();
  if (millis() - temperatureTimer >= 1000) {
    temperatureTimer=millis();
    dht11GetData();
    measure();
    lcddsp();
  }

  static int key_temp;
  
  static unsigned long rockerTimer=millis();
  if (millis() - rockerTimer >= 50) {
    rockerTimer=millis();
    int knobRaw=analogRead(RockerPin);
    
    if(knobRaw<70)
      key_value=1;  //right
    else if(70<=knobRaw&&knobRaw<235)
      key_value=5;  //push
    else if(235<=knobRaw&&knobRaw<420)
      key_value=2;  //up
    else if(420<=knobRaw&&knobRaw<620)
      key_value=3;  //left
    else if(620<=knobRaw&&knobRaw<900)
      key_value=4;  //dowm
    else
      key_value=0;
    
    if (key_value) {
      
      if (key_temp!=key_value) {
        BLUNOPlainProtocol.write("ROCKER", key_value);
      }
      
    }
    else{
      if(key_temp){
        BLUNOPlainProtocol.write("ROCKER", 0);
      }
    }
    key_temp=key_value;
    
  }
}


